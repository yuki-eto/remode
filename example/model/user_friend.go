// Code generated by generate_code script - DO NOT EDIT.
package model

import (
	"example/dao"
	"example/entity"
	"sort"
	"time"

	"github.com/juju/errors"
)

type UserFriendImpl struct {
	userFriendDao dao.UserFriend
}

func (m *UserFriendImpl) createInstance(e *entity.UserFriend) *UserFriendInstance {
	return &UserFriendInstance{
		UserFriend:    e,
		userFriendDao: m.userFriendDao,
	}
}

type UserFriendInstance struct {
	*entity.UserFriend
	userFriendDao dao.UserFriend
}

func (i *UserFriendInstance) Save() error {
	if i.userFriendDao == nil {
		return nil
	}
	return errors.Trace(i.userFriendDao.Save(i.UserFriend))
}

func (i *UserFriendInstance) Delete() error {
	if i.userFriendDao == nil {
		return nil
	}
	return errors.Trace(i.userFriendDao.Delete(i.UserFriend))
}

type UserFriendsInstance struct {
	values []*UserFriendInstance
}

func NewUserFriendsInstance() *UserFriendsInstance {
	return &UserFriendsInstance{values: []*UserFriendInstance{}}
}

func (i *UserFriendsInstance) Add(v *UserFriendInstance) {
	i.values = append(i.values, v)
}

func (i *UserFriendsInstance) FindByID(id uint64) *UserFriendInstance {
	for _, v := range i.values {
		if v.ID == id {
			return v
		}
	}
	return nil
}

func (i *UserFriendsInstance) FilterBy(f func(*UserFriendInstance) bool) *UserFriendsInstance {
	instance := NewUserFriendsInstance()
	for _, v := range i.values {
		if f(v) {
			instance.Add(v)
		}
	}
	return instance
}

func (i *UserFriendsInstance) Each(f func(*UserFriendInstance)) {
	for _, v := range i.values {
		f(v)
	}
}

func (i *UserFriendsInstance) EachWithError(f func(*UserFriendInstance) error) error {
	for _, v := range i.values {
		if err := f(v); err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

func (i *UserFriendsInstance) First() *UserFriendInstance {
	if len(i.values) == 0 {
		return nil
	}
	return i.values[0]
}

func (i *UserFriendsInstance) At(idx int) *UserFriendInstance {
	if len(i.values) < idx {
		return nil
	}
	return i.values[idx]
}

func (i *UserFriendsInstance) FilterByID(c uint64) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	for _, v := range i.values {
		if v.ID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserFriendsInstance) SortByID(isDesc bool) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].ID > s.values[j].ID
		}
		return s.values[i].ID < s.values[j].ID
	})
	return s
}

func (i *UserFriendsInstance) IDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UserFriendInstance) {
		s = append(s, v.ID)
	})
	return s
}

func (i *UserFriendsInstance) FilterByUserID(c uint64) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	for _, v := range i.values {
		if v.UserID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserFriendsInstance) SortByUserID(isDesc bool) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].UserID > s.values[j].UserID
		}
		return s.values[i].UserID < s.values[j].UserID
	})
	return s
}

func (i *UserFriendsInstance) UserIDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UserFriendInstance) {
		s = append(s, v.UserID)
	})
	return s
}

func (i *UserFriendsInstance) FilterByOtherUserID(c uint64) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	for _, v := range i.values {
		if v.OtherUserID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserFriendsInstance) SortByOtherUserID(isDesc bool) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].OtherUserID > s.values[j].OtherUserID
		}
		return s.values[i].OtherUserID < s.values[j].OtherUserID
	})
	return s
}

func (i *UserFriendsInstance) OtherUserIDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UserFriendInstance) {
		s = append(s, v.OtherUserID)
	})
	return s
}

func (i *UserFriendsInstance) FilterByCreatedAt(c *time.Time) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	for _, v := range i.values {
		if v.CreatedAt == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserFriendsInstance) SortByCreatedAt(isDesc bool) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].CreatedAt.Before(*s.values[j].CreatedAt)
		}
		return s.values[i].CreatedAt.After(*s.values[j].CreatedAt)
	})
	return s
}

func (i *UserFriendsInstance) CreatedAts() []*time.Time {
	s := []*time.Time{}
	i.Each(func(v *UserFriendInstance) {
		s = append(s, v.CreatedAt)
	})
	return s
}

func (i *UserFriendsInstance) FilterByUpdatedAt(c *time.Time) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	for _, v := range i.values {
		if v.UpdatedAt == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserFriendsInstance) SortByUpdatedAt(isDesc bool) *UserFriendsInstance {
	s := NewUserFriendsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].UpdatedAt.Before(*s.values[j].UpdatedAt)
		}
		return s.values[i].UpdatedAt.After(*s.values[j].UpdatedAt)
	})
	return s
}

func (i *UserFriendsInstance) UpdatedAts() []*time.Time {
	s := []*time.Time{}
	i.Each(func(v *UserFriendInstance) {
		s = append(s, v.UpdatedAt)
	})
	return s
}
