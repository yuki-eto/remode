package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"

	"github.com/iancoleman/strcase"
	"github.com/juju/errors"
	"github.com/yuki-eto/remodel"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v2"
)

func main() {
	if err := run(); err != nil {
		log.Fatalf("err: %+v", err)
	}
}

func run() error {
	var (
		rootDir    string
		moduleName string
		isProtoc   bool
	)
	flag.StringVar(&rootDir, "root", "", "root directory of project")
	flag.StringVar(&moduleName, "module", "", "module name of project")
	flag.BoolVar(&isProtoc, "proto", false, "necessary protocol buffers schema for entity")
	flag.Parse()

	if rootDir == "" {
		flag.Usage()
		return nil
	}

	mode := flag.Arg(0)
	switch mode {
	case "yaml":
		return outputYaml(rootDir)
	case "entity":
		if moduleName == "" {
			flag.Usage()
			return nil
		}
		return outputEntity(rootDir, isProtoc)
	case "dao":
		if moduleName == "" {
			flag.Usage()
			return nil
		}
		return outputDao(rootDir, moduleName)
	case "model":
		if moduleName == "" {
			flag.Usage()
			return nil
		}
		return outputModel(rootDir, moduleName)
	default:
		fmt.Println("please input mode: [yaml|entity|dao|model]")
		return nil
	}
}

func outputYaml(rootDir string) error {
	schemaDir := filepath.Join(rootDir, "schema")
	sqlDir := filepath.Join(schemaDir, "sql")
	if _, err := os.Stat(sqlDir); os.IsNotExist(err) {
		return errors.Trace(err)
	}
	yamlDir := filepath.Join(schemaDir, "yaml")
	if _, err := os.Stat(yamlDir); os.IsNotExist(err) {
		if err := os.Mkdir(yamlDir, 0755); err != nil {
			return errors.Trace(err)
		}
		fmt.Println(fmt.Sprintf("create directory: %s", yamlDir))
	}

	if err := filepath.Walk(sqlDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return errors.Trace(err)
		}
		if info.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".sql" {
			return nil
		}
		b, err := ioutil.ReadFile(path)
		if err != nil {
			return errors.Trace(err)
		}
		t := &remodel.Table{}
		if err := t.Parse(string(b)); err != nil {
			return errors.Trace(err)
		}
		ymlPath := filepath.Join(yamlDir, fmt.Sprintf("%s.yml", t.Name))
		f, err := os.Create(ymlPath)
		if err != nil {
			return errors.Trace(err)
		}
		enc := yaml.NewEncoder(f)
		if err := enc.Encode(t); err != nil {
			return errors.Trace(err)
		}
		if err := enc.Close(); err != nil {
			return errors.Trace(err)
		}
		fmt.Println(fmt.Sprintf("output: %s", ymlPath))
		return nil
	}); err != nil {
		return errors.Trace(err)
	}

	return nil
}

func applyGoimports(codePath string) error {
	importOpts := &imports.Options{
		TabWidth:  4,
		TabIndent: true,
		Comments:  true,
		Fragment:  true,
	}
	b, err := imports.Process(codePath, nil, importOpts)
	if err != nil {
		return errors.Trace(err)
	}
	if err := ioutil.WriteFile(codePath, b, os.ModePerm); err != nil {
		return errors.Trace(err)
	}
	return nil
}

func outputEntity(rootPath string, isProtoc bool) error {
	matches, err := filepath.Glob(filepath.Join(rootPath, "schema", "yaml", "*.yml"))
	if err != nil {
		return errors.Trace(err)
	}

	protoDir, err := filepath.Abs(filepath.Join(rootPath, "schema", "protobuf"))
	if err != nil {
		return errors.Trace(err)
	}
	if isProtoc {
		if _, err := os.Stat(protoDir); err != nil {
			if err := os.MkdirAll(protoDir, 0755); err != nil {
				return errors.Trace(err)
			}
			log.Printf("make directory: %s", protoDir)
		}
	}

	s := remodel.Entities{}
	for _, p := range matches {
		f, err := os.Open(p)
		if err != nil {
			return errors.Trace(err)
		}

		dec := yaml.NewDecoder(f)
		var t *remodel.Table
		if err := dec.Decode(&t); err != nil {
			return errors.Trace(err)
		}

		e := &remodel.Entity{}
		e.FromTable(t)

		entityPath, err := filepath.Abs(filepath.Join(rootPath, "entity", fmt.Sprintf("%s.go", strcase.ToSnake(e.Name))))
		if err != nil {
			return errors.Trace(err)
		}
		out, err := os.Create(entityPath)
		if err != nil {
			return errors.Trace(err)
		}
		if _, err := out.WriteString("// Code generated by generate_code script - DO NOT EDIT.\n"); err != nil {
			return errors.Trace(err)
		}
		if err := e.GenerateCode(out); err != nil {
			return errors.Trace(err)
		}
		if err := out.Close(); err != nil {
			return errors.Trace(err)
		}

		if err := applyGoimports(entityPath); err != nil {
			return errors.Trace(err)
		}

		log.Printf("output: %s", entityPath)
		s = append(s, e)

		if !isProtoc || e.IsReadOnly {
			continue
		}
		protoPath := filepath.Join(protoDir, fmt.Sprintf("%s_entity.proto", strcase.ToSnake(e.Name)))
		out, err = os.Create(protoPath)
		if err != nil {
			return errors.Trace(err)
		}
		if err := e.GenerateProtocolBuffers(out); err != nil {
			return errors.Trace(err)
		}
		if err := f.Close(); err != nil {
			return errors.Trace(err)
		}
		log.Printf("output: %s", protoPath)
	}

	structablePath := filepath.Join(rootPath, "entity", "structable.go")
	out, err := os.Create(structablePath)
	if err != nil {
		return errors.Trace(err)
	}
	if _, err := out.WriteString("// Code generated by generate_code script - DO NOT EDIT.\n"); err != nil {
		return errors.Trace(err)
	}
	if err := s.GenerateStructableCode(out); err != nil {
		return errors.Trace(err)
	}
	if err := out.Close(); err != nil {
		return errors.Trace(err)
	}
	if err := applyGoimports(structablePath); err != nil {
		return errors.Trace(err)
	}
	log.Printf("output: %s", structablePath)

	return nil
}

func outputDao(rootPath, moduleName string) error {
	matches, err := filepath.Glob(filepath.Join(rootPath, "schema", "yaml", "*.yml"))
	if err != nil {
		return errors.Trace(err)
	}

	for _, p := range matches {
		f, err := os.Open(p)
		if err != nil {
			return errors.Trace(err)
		}

		dec := yaml.NewDecoder(f)
		var t *remodel.Table
		if err := dec.Decode(&t); err != nil {
			return errors.Trace(err)
		}

		d := &remodel.Dao{}
		d.FromTable(t)

		daoPath, err := filepath.Abs(filepath.Join(rootPath, "dao", fmt.Sprintf("%s.go", strcase.ToSnake(d.Name))))
		if err != nil {
			return errors.Trace(err)
		}

		out, err := os.Create(daoPath)
		if err != nil {
			return errors.Trace(err)
		}
		if err := d.GenerateCode(out, moduleName); err != nil {
			return errors.Trace(err)
		}
		if err := out.Close(); err != nil {
			return errors.Trace(err)
		}

		if err := applyGoimports(daoPath); err != nil {
			return errors.Trace(err)
		}

		log.Printf("output: %s", daoPath)
	}

	return nil
}

func outputModel(rootPath, moduleName string) error {
	matches, err := filepath.Glob(filepath.Join(rootPath, "schema", "yaml", "*.yml"))
	if err != nil {
		return errors.Trace(err)
	}

	for _, p := range matches {
		f, err := os.Open(p)
		if err != nil {
			return errors.Trace(err)
		}

		dec := yaml.NewDecoder(f)
		var t *remodel.Table
		if err := dec.Decode(&t); err != nil {
			return errors.Trace(err)
		}

		m := &remodel.Model{}
		m.FromTable(t)

		modelPath, err := filepath.Abs(filepath.Join(rootPath, "model", fmt.Sprintf("%s.go", strcase.ToSnake(m.Name))))
		if err != nil {
			return errors.Trace(err)
		}

		out, err := os.Create(modelPath)
		if err != nil {
			return errors.Trace(err)
		}
		if _, err := out.WriteString("// Code generated by generate_code script - DO NOT EDIT.\n"); err != nil {
			return errors.Trace(err)
		}
		if err := m.GenerateCode(out, moduleName); err != nil {
			return errors.Trace(err)
		}
		if err := out.Close(); err != nil {
			return errors.Trace(err)
		}

		if err := applyGoimports(modelPath); err != nil {
			return errors.Trace(err)
		}

		log.Printf("output: %s", modelPath)
	}

	return nil
}
