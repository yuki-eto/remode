// Code generated by generate_code script - DO NOT EDIT.
package model

import (
	"sort"

	"github.com/juju/errors"
	"github.com/yuki-eto/remodel/example/dao"
	"github.com/yuki-eto/remodel/example/entity"
)

type UnitImpl struct {
	unitDao dao.Unit
}

func (m *UnitImpl) createInstance(e *entity.Unit) *UnitInstance {
	return &UnitInstance{Unit: e}
}

type UnitInstance struct {
	*entity.Unit
}
type UnitsInstance struct {
	values []*UnitInstance
}

func NewUnitsInstance() *UnitsInstance {
	return &UnitsInstance{values: []*UnitInstance{}}
}

func (i *UnitsInstance) Add(v *UnitInstance) {
	i.values = append(i.values, v)
}

func (i *UnitsInstance) FindByID(id uint64) *UnitInstance {
	for _, v := range i.values {
		if v.ID == id {
			return v
		}
	}
	return nil
}

func (i *UnitsInstance) FilterBy(f func(*UnitInstance) bool) *UnitsInstance {
	instance := NewUnitsInstance()
	for _, v := range i.values {
		if f(v) {
			instance.Add(v)
		}
	}
	return instance
}

func (i *UnitsInstance) Each(f func(*UnitInstance)) {
	for _, v := range i.values {
		f(v)
	}
}

func (i *UnitsInstance) EachWithError(f func(*UnitInstance) error) error {
	for _, v := range i.values {
		if err := f(v); err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

func (i *UnitsInstance) First() *UnitInstance {
	if len(i.values) == 0 {
		return nil
	}
	return i.values[0]
}

func (i *UnitsInstance) At(idx int) *UnitInstance {
	if len(i.values) < idx {
		return nil
	}
	return i.values[idx]
}

func (i *UnitsInstance) FilterByID(c uint64) *UnitsInstance {
	s := NewUnitsInstance()
	for _, v := range i.values {
		if v.ID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UnitsInstance) SortByID(isDesc bool) *UnitsInstance {
	s := NewUnitsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].ID > s.values[j].ID
		}
		return s.values[i].ID < s.values[j].ID
	})
	return s
}

func (i *UnitsInstance) IDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UnitInstance) {
		s = append(s, v.ID)
	})
	return s
}

func (i *UnitsInstance) FilterByType(c string) *UnitsInstance {
	s := NewUnitsInstance()
	for _, v := range i.values {
		if v.Type == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UnitsInstance) SortByType(isDesc bool) *UnitsInstance {
	s := NewUnitsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].Type > s.values[j].Type
		}
		return s.values[i].Type < s.values[j].Type
	})
	return s
}

func (i *UnitsInstance) Types() []string {
	s := []string{}
	i.Each(func(v *UnitInstance) {
		s = append(s, v.Type)
	})
	return s
}

func (i *UnitsInstance) FilterByRarity(c string) *UnitsInstance {
	s := NewUnitsInstance()
	for _, v := range i.values {
		if v.Rarity == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UnitsInstance) SortByRarity(isDesc bool) *UnitsInstance {
	s := NewUnitsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].Rarity > s.values[j].Rarity
		}
		return s.values[i].Rarity < s.values[j].Rarity
	})
	return s
}

func (i *UnitsInstance) Rarities() []string {
	s := []string{}
	i.Each(func(v *UnitInstance) {
		s = append(s, v.Rarity)
	})
	return s
}

func (i *UnitsInstance) FilterByName(c string) *UnitsInstance {
	s := NewUnitsInstance()
	for _, v := range i.values {
		if v.Name == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UnitsInstance) SortByName(isDesc bool) *UnitsInstance {
	s := NewUnitsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].Name > s.values[j].Name
		}
		return s.values[i].Name < s.values[j].Name
	})
	return s
}

func (i *UnitsInstance) Names() []string {
	s := []string{}
	i.Each(func(v *UnitInstance) {
		s = append(s, v.Name)
	})
	return s
}

func (i *UnitsInstance) FilterByMaxCount(c uint16) *UnitsInstance {
	s := NewUnitsInstance()
	for _, v := range i.values {
		if v.MaxCount == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UnitsInstance) SortByMaxCount(isDesc bool) *UnitsInstance {
	s := NewUnitsInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].MaxCount > s.values[j].MaxCount
		}
		return s.values[i].MaxCount < s.values[j].MaxCount
	})
	return s
}

func (i *UnitsInstance) MaxCounts() []uint16 {
	s := []uint16{}
	i.Each(func(v *UnitInstance) {
		s = append(s, v.MaxCount)
	})
	return s
}
