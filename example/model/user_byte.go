// Code generated by generate_code script - DO NOT EDIT.
package model

import (
	"bytes"
	"example/dao"
	"example/entity"
	"sort"
	"strings"
	"time"

	"github.com/juju/errors"
)

type UserByteImpl struct {
	userByteDao dao.UserByte
}

func (m *UserByteImpl) createInstance(e *entity.UserByte) *UserByteInstance {
	return &UserByteInstance{
		UserByte:    e,
		userByteDao: m.userByteDao,
	}
}

type UserByteInstance struct {
	*entity.UserByte
	userByteDao dao.UserByte
}

func (i *UserByteInstance) Save() error {
	if i.userByteDao == nil {
		return nil
	}
	return errors.Trace(i.userByteDao.Save(i.UserByte))
}

func (i *UserByteInstance) Delete() error {
	if i.userByteDao == nil {
		return nil
	}
	return errors.Trace(i.userByteDao.Delete(i.UserByte))
}

type UserBytesInstance struct {
	values []*UserByteInstance
}

func NewUserBytesInstance() *UserBytesInstance {
	return &UserBytesInstance{values: []*UserByteInstance{}}
}

func (i *UserBytesInstance) Add(v *UserByteInstance) {
	i.values = append(i.values, v)
}

func (i *UserBytesInstance) FindByID(id uint64) *UserByteInstance {
	for _, v := range i.values {
		if v.ID == id {
			return v
		}
	}
	return nil
}

func (i *UserBytesInstance) FilterBy(f func(*UserByteInstance) bool) *UserBytesInstance {
	instance := NewUserBytesInstance()
	for _, v := range i.values {
		if f(v) {
			instance.Add(v)
		}
	}
	return instance
}

func (i *UserBytesInstance) Each(f func(*UserByteInstance)) {
	for _, v := range i.values {
		f(v)
	}
}

func (i *UserBytesInstance) EachWithError(f func(*UserByteInstance) error) error {
	for _, v := range i.values {
		if err := f(v); err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

func (i *UserBytesInstance) First() *UserByteInstance {
	if len(i.values) == 0 {
		return nil
	}
	return i.values[0]
}

func (i *UserBytesInstance) At(idx int) *UserByteInstance {
	if len(i.values) < idx {
		return nil
	}
	return i.values[idx]
}

func (i *UserBytesInstance) Len() int {
	return len(i.values)
}

func (i *UserBytesInstance) IsEmpty() bool {
	return i.Len() == 0
}

func (i *UserBytesInstance) FilterByID(c uint64) *UserBytesInstance {
	s := NewUserBytesInstance()
	for _, v := range i.values {
		if v.ID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByID(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].ID > s.values[j].ID
		}
		return s.values[i].ID < s.values[j].ID
	})
	return s
}

func (i *UserBytesInstance) IDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.ID)
	})
	return s
}

func (i *UserBytesInstance) FilterByUserID(c uint64) *UserBytesInstance {
	s := NewUserBytesInstance()
	for _, v := range i.values {
		if v.UserID == c {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByUserID(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].UserID > s.values[j].UserID
		}
		return s.values[i].UserID < s.values[j].UserID
	})
	return s
}

func (i *UserBytesInstance) UserIDs() []uint64 {
	s := []uint64{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.UserID)
	})
	return s
}

func (i *UserBytesInstance) FilterByBytes(c []byte) *UserBytesInstance {
	s := NewUserBytesInstance()
	for _, v := range i.values {
		if bytes.Equal(v.Bytes, c) {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByBytes(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return bytes.Compare(s.values[i].Bytes, s.values[j].Bytes) > 0
		}
		return bytes.Compare(s.values[i].Bytes, s.values[j].Bytes) < 0
	})
	return s
}

func (i *UserBytesInstance) Bytes() [][]byte {
	s := [][]byte{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.Bytes)
	})
	return s
}

func (i *UserBytesInstance) FilterByTags(c []string) *UserBytesInstance {
	s := NewUserBytesInstance()
	sort.Strings(c)
	cs := strings.Join(c, ",")
	for _, v := range i.values {
		vs := v.Tags
		sort.Strings(vs)
		if strings.Join(vs, ",") == cs {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByTags(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return strings.Join(s.values[i].Tags, ",") < strings.Join(s.values[j].Tags, ",")
		}
		return strings.Join(s.values[i].Tags, ",") > strings.Join(s.values[j].Tags, ",")
	})
	return s
}

func (i *UserBytesInstance) Tags() [][]string {
	s := [][]string{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.Tags)
	})
	return s
}

func (i *UserBytesInstance) FilterByCreatedAt(c *time.Time) *UserBytesInstance {
	s := NewUserBytesInstance()
	for _, v := range i.values {
		if v.CreatedAt.Equal(*c) {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByCreatedAt(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].CreatedAt.Before(*s.values[j].CreatedAt)
		}
		return s.values[i].CreatedAt.After(*s.values[j].CreatedAt)
	})
	return s
}

func (i *UserBytesInstance) CreatedAts() []*time.Time {
	s := []*time.Time{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.CreatedAt)
	})
	return s
}

func (i *UserBytesInstance) FilterByUpdatedAt(c *time.Time) *UserBytesInstance {
	s := NewUserBytesInstance()
	for _, v := range i.values {
		if v.UpdatedAt.Equal(*c) {
			s.Add(v)
		}
	}
	return s
}

func (i *UserBytesInstance) SortByUpdatedAt(isDesc bool) *UserBytesInstance {
	s := NewUserBytesInstance()
	s.values = i.values
	sort.SliceStable(s.values, func(i, j int) bool {
		if isDesc {
			return s.values[i].UpdatedAt.Before(*s.values[j].UpdatedAt)
		}
		return s.values[i].UpdatedAt.After(*s.values[j].UpdatedAt)
	})
	return s
}

func (i *UserBytesInstance) UpdatedAts() []*time.Time {
	s := []*time.Time{}
	i.Each(func(v *UserByteInstance) {
		s = append(s, v.UpdatedAt)
	})
	return s
}

func (i *UserBytesInstance) Save() error {
	return i.EachWithError(func(i *UserByteInstance) error {
		return errors.Trace(i.Save())
	})
}
